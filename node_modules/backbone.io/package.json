{
  "name": "backbone.io",
  "version": "0.3.1",
  "description": "Backbone.js sync via Socket.IO",
  "homepage": "http://github.com/scttnlsn/backbone.io",
  "author": {
    "name": "Scott Nelson",
    "email": "scottbnel@gmail.com"
  },
  "main": "./lib/index",
  "repository": {
    "type": "git",
    "url": "git://github.com/scttnlsn/backbone.io.git"
  },
  "dependencies": {
    "socket.io": ">= 0.8.7"
  },
  "devDependencies": {
    "express": ">= 2.5.0",
    "mocha": ">= 0.3.6",
    "sinon": ">= 1.2.0"
  },
  "readme": "Backbone.IO\n===========\n\nBackend-agnostic Backbone.js sync override and server notifications via Socket.IO.\n\nInstall\n-------\n\n    npm install backbone.io\n    \nUsage\n-----\n\nOn the server:\n\n    var http = require('http');\n    var backboneio = require('backbone.io');\n    \n    var app = http.createServer();    \n    app.listen(3000);\n\n    var backend = backboneio.createBackend();\n    backend.use(backboneio.middleware.memoryStore());\n    \n    backboneio.listen(app, { mybackend: backend });\n\nOn the client:\n\n    <!-- Include Underscore, Backbone -->\n    \n    <script src=\"/socket.io/socket.io.js\"></script>\n    <script src=\"/socket.io/backbone.io.js\"></script>\n    \n    <script>\n        Backbone.io.connect();\n\n        var MyCollection = Backbone.Collection.extend({\n            backend: 'mybackend'\n        });\n    </script>\n    \nModels in `MyCollection` will now be synced to `mybackend`.\n\nNote that as of 0.3.x, one must explicitly call `Backbone.io.connect`.  Any\noptional arguments will be passed to Socket.IO's `io.connect` function.\n\nEvents\n------\n\nWhen a model is synced with a particular backend, the backend will trigger events\non collections (across multiple clients) that share the backend.  For example, we\ncould keep collections synced in realtime with the following event bindings:\n\n    var MyCollection = Backbone.Collection.extend({\n        \n        backend: 'mybackend',\n        \n        initialize: function() {\n            var self = this;\n        \n            this.bind('backend:create', function(model) {\n                self.add(model);\n            });\n            this.bind('backend:update', function(model) {\n                self.get(model.id).set(model);\n            });\n            this.bind('backend:delete', function(model) {\n                self.remove(model.id);\n            });\n        }\n        \n    });\n    \nOr use the provided shortcut:\n    \n    backend: 'mybackend',\n    \n    initialize: function() {\n        this.bindBackend();\n    }\n    \nIn addition to `backend:create`, `backend:read`, `backend:update`, and `backend:delete`\nevents, a generic `backend` event is also triggered when a model is synced.\n\n    this.bind('backend', function(method, model) {\n        // Method will be one of create, read, update, or delete\n    });\n    \nThe event prefix `backend` is used by default but this can be customized by setting the\nevent name on the server.\n\n    backboneio.listen(app, { mybackend: backend }, { event: 'myevent' });\n\nBackends and Middleware\n-----------------------\n\nBackends are stacks of composable middleware (inspired by Connect) that are responsible\nfor handling sync requests and responding appropriately.  Each middleware is a function\nthat accepts request and response objects (and optionally a function that can be called\nto continue down the stack).  A middleware will generally either return a result by\ncalling `end` on the response object or pass control downward.  For example, let's add a\nlogger middleware to our backend:\n\n    var backend = backboneio.createBackend();\n    \n    backend.use(function(req, res, next) {\n        console.log(req.backend);\n        console.log(req.method);\n        console.log(JSON.stringify(req.model));\n        next();\n    });\n    \n    backend.use(backboneio.middleware.memoryStore());\n    \nA request object will contain the following components (in addition to those set by\nvarious middleware):\n\n* `method`: the sync method (`create`, `read`, `update`, or `delete`)\n* `model`: the model object to by synced\n* `options`: any options set by the client (except success and error callbacks)\n* `backend`: name of the backend responsible for handling the request\n* `socket`: the client socket that initiated the request\n    \nMiddleware can also be applied to only particular types of requests by passing the desired\ncontexts to `use`:\n\n    backend.use('create', 'update', 'delete', function(req, res, next) {\n        if (isAuthorized(req)) {\n            next();\n        } else {\n            next(new Error('Unauthorized'));\n        }\n    });\n    \nOr alternatively by using one of the four helper methods (`create`, `read`, `update`, `delete`):\n\n    backend.read(function(req, res) {\n        if (req.model.id) {\n            req.end(mymodels[req.model.id]);\n        } else {\n            req.end(mymodels);\n        }\n    });\n    \nIf the bottom of the middleware stack is reached before a result is returned then the requested\nmodel is returned by default: `res.end(req.model)`.  Look in the `middleware` directory for more\nexamples.\n\nClients are automatically notified of events triggered by other clients, however, there may\nbe cases where other server-side code needs to make updates to a model outside of a backend\nhandler.  In such a case, one can notify clients by emitting events directly on the backend.\nFor example:\n\n    var backend = backboneio.createBackend();\n    backend.use(backboneio.middleware.memoryStore());\n    \n    // Clients will receive 'backend:create', 'backend:update',\n    // and 'backend:delete' events respectively.\n    backend.emit('created', { id: 'myid', foo: 'bar' });\n    backend.emit('updated', { id: 'myid', foo: 'baz' });\n    backend.emit('deleted', { id: 'myid' });\n\nChannels\n--------\n\nTo synchronize models between a subset of all clients sharing a single backend, you can\nspecify a channel.\n\n    var MyCollection = Backbone.Collection.extend({\n        \n        backend: { name: 'mybackend', channel: 'mychannel' }\n        \n    });\n\nOnly clients sharing the same channel will receive updates from each other.  The channel\nassociated with a given request is available from any middleware in `req.channel`.\n    \nCustomizing\n-----------\n\nIn addition to middleware, the behavior of Backbone.IO can be customized via standard Socket.IO\nmechanisms.  The object returned from the call to `listen` is the Socket.IO object and can be\nmanipulated further.  See http://socket.io for more details.\n\nTests\n-----\n\nInstall development dependencies:\n\n    npm install\n    \nRun the test suite:\n\n    make test",
  "_id": "backbone.io@0.3.1",
  "_from": "backbone.io"
}
